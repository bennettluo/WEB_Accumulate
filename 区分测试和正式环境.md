# 区分测试和正式环境 

# 改变运行脚本的环境变量

在执行的命令中设置变量,区分测试和正式环境

主要依靠node的process.env

process 是node的全局对象

而process.env提供执行环境的环境变量

```shell
//改变命令的环境变量
$ export NODE_ENV=production && node app.js
# 或者
$ NODE_ENV=production node app.js
```

而在webpack中,就可以通过`process.env.NODE_ENV`获取变量

# 正式和测试环境区分压缩

例如我们在测试环境下不压缩

而上线的时候压缩

正规的做法有3个webpack配置文件

分别为

```javascript
webpack.config.js
webpack.dev.js
webpack.production.js
```
在webpack.config.js区分process.env.NODE_ENV来决定读取webpack.dev还是webpack.production

而我比较懒,因为这个需求比较简单

我就在webpack.config定义一个公共的config对象

而对正式环境进行特殊处理

```javascript
if (process.env.NODE_ENV === 'production') {
    //config.entry.index.shift()
    config.plugins.push(
        new webpack.optimize.UglifyJsPlugin()
    )
}

```

现在我们输入

`export NODE_ENV=production&&webpack`就会压缩文件

`export NODE_ENV=dev&&webpack`则不会压缩文件

# 配置到package.json

一般的测试和正式的命令都会比较长

我们可以把常用的命令放在package.json里的scripts属性里

```javascript
{
  "scripts": {
    "dev": "export NODE_ENV=dev&&webpack  --progress --colors",
    "production": "export NODE_ENV=production&&webpack  --progress --colors",
  },
```

这样我们在项目根目录输入

npm run dev //测试
npm run production //正式

# 在浏览器中区分测试和



# 参考链接

1. process: http://javascript.ruanyifeng.com/nodejs/process.html